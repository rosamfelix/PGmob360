---
eval: true
code-fold: false
engine: knitr
---

# Tratamento de dados

Neste cap√≠tulo, utilizaremos algumas fun√ß√µes muito √∫teis do `dplyr` para tratar e manipular dados.

Pode carregar o pacote `dplyr` diretamente ou carregar todo o universo tidy (`tidyverse`) que cont√©m outros pacotes como o `ggplot2` para fazer gr√°ficos.

```{r}
#| message: false
# library(tidyverse)
library(dplyr)
```

Iremos usar uma base de dados do IMOB [@IMOB] com as viagens entre freguesias da √°rea metropolitana de Lisboa, por modo de transporte.

Faremos um tratamento de dados de forma simplificada, usando as mais recentes boas-pr√°ticas de utiliza√ß√£o de linguagem R.

```{r}
#| include: false
#| eval: false
# data preparation
TABLE = readRDS(url("https://github.com/U-Shift/MQAT/raw/main/data/IMOBmodel0.Rds"))
TABLE = TABLE |> 
  rename(Origem = "Origem_dicofre16",
         Interna = "internal") |> 
  select(1,3:8,2,9)
saveRDS(TABLE, "data/TRIPSorigem.Rds")

Municipios = readRDS(url("https://github.com/U-Shift/MQAT/raw/main/data/Dicofre_names.Rds"))

saveRDS(Municipios, "data/Municipios_nomes.Rds")
write.table(Municipios, "data/Municipios_nomes.txt", row.names = FALSE, sep = "\t")
```

```{r}
# ler os dados diretamente em formato R dataset
TRIPS = readRDS("data/TRIPSorigem.Rds")
```

::: callout-important
Note que √© muito importante compreender o R base, mesmo que as fun√ß√µes seguintes forne√ßam os mesmos resultados.
:::

N√£o √© necess√°rio saber tudo!
E **n√£o precisa de saber de cor**.
As fun√ß√µes seguintes s√£o as que provavelmente utilizar√° na maior parte das vezes para tratar dados.

::: {.callout-tip appearance="simple"}
Existem v√°rias formas de chegar √† mesma solu√ß√£o.
Aqui apresento apenas uma delas.
:::

## Selecionar vari√°veis

D√™ uma vista de olhos ao seu conjunto de dados.
Pode abrir a tabela utilizando `View()`, ver a informa√ß√£o no painel ‚ÄúEnvironment‚Äù, ou mesmo *imprimir* o conte√∫do estruturado com `glimpse()`

```{r}
glimpse(TRIPS)
```

Vamos criar um novo conjunto de dados com *Origem*, *Walk,* *Bike* e *Total*.
Usamos a fun√ß√£o `select()`.

```{r}
TRIPS_new = select(TRIPS, Origem, Walk, Bike, Total) # o primeiro argumento √© a base de dados
```

Em R, o primeiro argumento √© normalmente referente ao conjunto de dados, e os restantes s√£o as colunas a selecionar.

Com o `dplyr` n√£o √© necess√°rio referir a `data$...` , podemos simplesmente escrever os nomes das vari√°veis (e mesmo sem o `‚Äú...‚Äù`!).
Isto torna o c√≥digo em R mais simples üôÇ

Com o `select()` podemos tamb√©m remover colunas que n√£o precisamos.

```{r}
TRIPS_new = select(TRIPS_new, -Total) # deixar cair a vari√°vel Total
```

### Usando pipes!

Agora vamos passar a usar os *pipes*.
Os *pipes* funcionam como uma regra: "**Com isto, faz isto.**"

Isto √© √∫til para omitir o primeiro argumento das fun√ß√µes (normalmente o conjunto de dados para aplicar a fun√ß√£o).

Com o mesmo exemplo do `select()`, podemos escrever como:

```{r}
TRIPS_new = TRIPS |> select(Origem, Walk, Bike, Total)
```

Duas coisas a **ter em conta**:

1.  O s√≠mbolo do *pipe* pode ser escrito como `|>` ou `%>%`.[^data-manipulation-1]
    Para o escrever, pode tamb√©m utilizar o atalho `ctrl+shift+m`.

2.  Depois de escrever `select(` pode premir `tab` e aparecer√° a lista de vari√°veis dispon√≠veis desse conjunto de dados! Prima `Enter` para selecionar. Desta forma, evita erros de digita√ß√£o.

[^data-manipulation-1]: Pode alterar isto em RStudio \> Tools \> Global Options \> Code.

## Filtrar observa√ß√µes

Podemos filtrar observa√ß√µes, com base numa condi√ß√£o, utilizando a fun√ß√£o `filter()`.

```{r}
TRIPS2 = TRIPS[TRIPS$Total > 25000,] # usando o r-base, n√£o se pode esquecer a v√≠rgula
TRIPS2 = TRIPS2 |> filter(Total > 25000) # usando o dplyr, √© mais f√°cil
```

√â poss√≠vel ter outras condi√ß√µes dentro da condi√ß√£o.

```{r}
summary(TRIPS$Total)
TRIPS3 = TRIPS |> filter(Total > median(Total)) 
```

Outras condi√ß√µes de filtragem:

-   `==` igual, `!=` diferente
-   `<` menor, `>` maior, `<=` menor ou igual, `>=` maior ou igual
-   `&` e, `|` ou
-   `is.na`, `!is.na` n√£o √© NA
-   `%in%`, `!%in%` n√£o est√° em

## Criar novas vari√°veis

Tamb√©m podemos tentar criar uma vari√°vel de percentagem de viagens em autom√≥vel (*Car*) usando pipes!
Para criar uma nova vari√°vel ou alterar uma existente (overwrite), podemos usar a fun√ß√£o `mutate()`.

```{r}
TRIPS$Car_perc = TRIPS$Car/TRIPS$Total * 100 # com o r-base

TRIPS = TRIPS |> mutate(Car_perc = Car/Total * 100) # com o dplyr
```

## Alterar o tipo de dados

Os dados podem estar em diferentes formatos.
Por exemplo, a vari√°vel *Origem* tem os c√≥digos das freguesias como texto (*character*), mas podemos convert√™-la numa vari√°vel num√©rica.

```{r}
class(TRIPS$Origem)
TRIPS = TRIPS |> 
  mutate(Origem_num = as.integer(Origem)) # tamb√©m podemos usar as.numeric()
class(TRIPS$Origem_num)
```

Os tipos de dados mais utilizados s√£o:

-   inteiro / integer (`int`)
-   num√©rico / numeric (`num`)
-   texto/ character (`chr`)
-   l√≥gico / logical (`logical`)
-   data / date (`Date`)
-   factor (`factor`)

### Factores

Os factores s√£o √∫teis para lidar com dados categ√≥ricos.
Podemos converter um texto num fator usando `as.factor()`, e tamb√©m atribuir etiquetas e n√≠veis para dados categ√≥ricos ordinais.

Podemos alterar a vari√°vel `Lisbon` para um factor, e a vari√°vel `Internal` tamb√©m.

```{r}
TRIPS = TRIPS |> 
  mutate(Lisboa_factor = factor(Lisboa, labels = c("N√£o", "Sim")),
         Interna_factor = factor(Interna, labels = c("Externa", "Interna")))
```

Mas como saber qual o n√≠vel que vem primeiro?
Uma forma simples √© utilizar as fun√ß√µes `table()` ou `unique()`.

```{r}
unique(TRIPS$Lisboa) # isto mostra todos os valores √∫nicos (diferentes)
table(TRIPS$Lisboa) # isto mostra a frequ√™ncia de cada valor
table(TRIPS$Lisboa_factor)
```

O primeiro n√∫mero a aparecer corresponde ao primeiro n√≠vel, e assim sucessivamente.

Podemos ver a diferen√ßa entre usar uma vari√°vel cont√≠nua (neste caso, `Lisboa` tem 0 e 1) e uma vari√°vel categ√≥rica (`Lisboa_factor`).

```{r}
plot(TRIPS$Lisboa) # os valores variam entre 0 e 1
plot(TRIPS$Lisboa_factor) # os valores s√£o categ√≥ricos e com etiquetas Sim/N√£o
```

## Juntar tabelas de dados

Quando temos tabelas relacionais - ou seja, com um identificador comum - √© √∫til poder junt√°-las de uma forma eficiente.

O `left_join` √© uma fun√ß√£o que junta duas tabelas atrav√©s de **uma vari√°vel comum**.
A **primeira tabela √© a que ser√° mantida**, e a **segunda ser√° acrescentada a ela**.
Como funciona o `left_join`:

[![Uma representa√ß√£o visual do left_join em que todas as linhas de x aparecem no resultado final, com mais informa√ß√£o junta de y. Fonte: .](images/clipboard-1594422253.png){fig-align="center" width="424"}](https://r4ds.hadley.nz/joins#fig-join-left)

Vamos ent√£o **juntar a lista de munic√≠pios √† nossa tabela**, atrav√©s de uma outra base de dados que inclui a **rela√ß√£o** entre o c√≥digo de freguesias (dicofre), o nome das freguesias e os respetivos munic√≠pios.

```{r}
Municipios = readRDS("data/Municipios_nomes.Rds")
```

```{r}
head(TRIPS)
tail(Municipios)
```

Podemos observar que as tabelas t√™m vari√°veis comuns: a `Origem` em `TRIPS` e o `Dicofre` em `Municipios`.

Uma vez que o nome da vari√°vel n√£o √© o mesmo, para juntar estas duas tabelas precisamos de especificar a vari√°vel comum em cada tabela, utilizando o argumento `by`.

```{r}
TRIPSjoin = TRIPS |> left_join(Municipios, by = c("Origem" = "Dicofre"))
```

Se preferir, pode alterar ou renomear uma vari√°vel para que ambas as tabelas tenham o mesmo nome.
**Quando ambas as tabelas t√™m o mesmo nome de vari√°vel**, n√£o √© preciso especificar o argumento `by`.

```{r}
#| message: false
Municipios = Municipios |> rename(Origem = "Dicofre") # alterar o nome da vari√°vel
TRIPSjoin = TRIPS |> left_join(Municipios) # detecta automativamente a vari√°vel comum
```

> Como √© poss√≠vel observar, as duas tabelas n√£o precisam de ter o mesmo n√∫mero de linhas (`nrow()`).
> A fun√ß√£o `left_join` mant√©m todas as observa√ß√µes da primeira tabela e junta a segunda tabela a esta.
> Se n√£o houver correspond√™ncia, as vari√°veis da segunda tabela ser√£o preenchidas com `NA`.

## group_by e summarize

Temos uma tabela grande com todas as freguesias da AML e os seus respectivos munic√≠pios.
Queremos agora saber o n√∫mero total de viagens com origem em cada munic√≠pio.

Para facilitar, vamos manter apenas as vari√°veis de que precisamos para chegar ao resultado.

```{r}
TRIPSredux = TRIPSjoin |> select(Origem, Concelho, Interna, Car, Total)
head(TRIPSredux)
```

Podemos agrupar esta tabela pela vari√°vel `Concelho` e sumarizar (*summarize*) o n√∫mero de viagens com origem em cada munic√≠pio.

```{r}
#| message: false
TRIPSsum = TRIPSredux |> 
  group_by(Concelho) |> # n√£o ir√° notar nenhuma altera√ß√£o na tabela
  summarize(Total = sum(Total))
head(TRIPSsum)
```

Som√°mos o n√∫mero total de viagens em cada munic√≠pio.

Se quisermos agrupar por mais do que uma vari√°vel, podemos adicionar mais vari√°veis ao `group_by()`.

```{r}
#| message: false
TRIPSsum2 = TRIPSredux |> 
  group_by(Concelho, Interna) |> 
  summarize(Total = sum(Total),
            Car = sum(Car))
head(TRIPSsum2)
```

Som√°mos o n√∫mero total de viagens e viagens em autom√≥vel para cada munic√≠pio, discriminadas por desloca√ß√µes internas e externas.

::: {.callout-caution appearance="simple"}
√â uma boa pr√°tica utilizar a fun√ß√£o `ungroup()` ap√≥s a fun√ß√£o `group_by()`.
Isso remover√° o agrupamento.
Se n√£o o fizer, o agrupamento ser√° mantido e poder√° obter resultados inesperados na pr√≥xima vez que utilizar esse conjunto de dados.
:::

## Organizar os dados

Podemos **ordenar** (*sort*) um conjunto de dados por uma ou mais vari√°veis.

Por exemplo, `arrange()` por Total de viagens, na ordem ascendente ou descendente.

```{r}
TRIPS2 = TRIPSsum2 |> arrange(Total)
TRIPS2 = TRIPSsum2 |> arrange(-Total) # descendente

TRIPS2 = TRIPSsum2 |> arrange(Concelho) # alfab√©tica

TRIPS4 = TRIPS |> arrange(Lisboa_factor, Total) # mais de uma vari√°vel
```

Isto n√£o √© o mesmo que abrir a tabela de visualiza√ß√£o e clicar nas setas das vari√°veis.
Quando se faz isso, a ordem n√£o √© guardada no conjunto de dados.
Se quiser guardar a ordem, dever√° usar a fun√ß√£o `arrange()`.

## All together now!

Esta √© a magia dos *pipes*.
O pipe pega no √∫ltimo resultado e aplica-lhe a fun√ß√£o seguinte.
‚ÄúCom isto, faz isto.‚Äù.
Podemos encadear as fun√ß√µes que quisermos.

```{r}
#| message: false
TRIPS_pipes = TRIPS |> 
  select(Origem, Interna, Car, Total) |> 
  
  mutate(Dicofre = Origem) |> 
  mutate(Interna_factor = factor(Interna, labels = c("Externa", "Interna"))) |> 
  
  filter(Interna_factor == "Interna")|>
  
  left_join(Municipios) |>
  
  group_by(Concelho) |>
  summarize(Total = sum(Total),
            Car = sum(Car),
            Car_perc = Car/Total * 100) |> 
  ungroup() |> 
  
  arrange(desc(Car_perc))
```

Com este c√≥digo, teremos uma tabela com o n√∫mero total de viagens intramunicipais, por munic√≠pio, com os seus nomes em vez de c√≥digos, ordenados pela percentagem de viagens em autom√≥vel.

```{r}
TRIPS_pipes
```

## Gr√°fico com ggplot

O `ggplot` permite fazer v√°rios tipos de gr√°fico.
**N√£o √© f√°cil** de entender √† primeira a sua estrutura, e muitas vezes recorre-se a exemplos na internet, adaptando as vari√°veis em uso.

Aqui fica um exemplo de gr√°fico com a base de dados que prepar√°mos.

```{r}
library(ggplot2) # carregar o pacote

# prepar dados
TRIPSplot = TRIPS2 |>
  mutate(Interna = factor(Interna, labels = c("Externa", "Interna"))) |> # num√©rico para fator
  arrange(-Total) # ordem decrescente

# gr√°fico com ggplot
ggplot(data = TRIPSplot, aes(x = Concelho, y = Total, fill = Interna)) +
  geom_bar(stat = "identity", position = position_stack()) + # position_dodge
  labs(title = "Numero de viagens por municipio",
       x = "Munic√≠pio",
       y = "Numero de viagens",
       fill = "Tipo") +
  theme_minimal()
```

## Outras fun√ß√µes do dplyr

Pode explorar outras fun√ß√µes e varia√ß√µes do `dplyr` para manipula√ß√£o de dados na **dplyr cheatsheet**:

[![](images/clipboard-2101323289.png)](https://rstudio.github.io/cheatsheets/data-transformation.pdf)

Take a particular attention to `pivot_wider` and `pivot_longer` ([`tidyr`](https://tidyr.tidyverse.org/articles/pivot.html) package) to transform **OD matrices** in **wide** and **long** formats.

Tome especial aten√ß√£o a `pivot_wider` e `pivot_longer` (pacote [`tidyr`](https://tidyr.tidyverse.org/articles/pivot.html) ) para transformar **matrizes OD** em formatos largos (*wide*) ou longos (*long*).

```{r}
#| echo: false
#| eval: true
pivot = data.frame(Origens = c("A", "A", "B", "C", "C"),
                   Destinos = c("B", "C", "A", "C", "A"),
                   Viagens = c(20, 45, 10, 5, 30))
knitr::kable(pivot, caption = "Matriz OD em formato longo")
```

```{r}
#| echo: false
#| eval: true
matrix = pivot |> 
  tidyr::pivot_wider(names_from = Destinos,
                                     values_from = Viagens,
                                     names_sort = TRUE) |> 
  dplyr::rename(Viagens = "Origens")
knitr::kable(matrix, caption = "matriz OD em formato wide")
```

```{r}
#| include: false
#| echo: false
#| eval: false
# this converts this quarto to a plain r script
knitr::purl("data-manipulation.qmd", "code/tratamento-dados.R", documentation = 0)
```
